---
title: "üå∏ Max Min Height | GFG Solution üíß"
keywordsüè∑Ô∏è: ["üå∏ max min height", "üíß flower watering", "üîç binary search", "üìà greedy algorithm", "üìò GFG", "üèÅ competitive programming", "üìö DSA"]
author: "‚úçÔ∏è Het Patel (Hunterdii)"
description: "‚úÖ GFG solution to the Max Min Height problem: maximize minimum flower height after k days of watering using binary search and greedy strategy. üöÄ"
date: üìÖ 2025-06-30
---

# *30. Max Min Height*

The problem can be found at the following link: üîó [Question Link](https://www.geeksforgeeks.org/problems/max-min-height--170647/1)

## **üß© Problem Description**

Given a garden with **n flowers** planted in a row, represented by an array `arr[]` where `arr[i]` denotes the height of the ith flower. You will water them for **k days**. In one day you can water **w continuous flowers**. Whenever you water a flower its height increases by **1 unit**. You have to **maximize the minimum height** of all flowers after k days of watering.

## **üìò Examples**

### Example 1

```cpp
Input: arr[] = [2, 3, 4, 5, 1], k = 2, w = 2
Output: 2
Explanation: The minimum height after watering is 2.
Day 1: Water the last two flowers -> arr becomes [2, 3, 4, 6, 2]
Day 2: Water the last two flowers -> arr becomes [2, 3, 4, 7, 3]
```

### Example 2

```cpp
Input: arr[] = [5, 8], k = 5, w = 1
Output: 9
Explanation: The minimum height after watering is 9.
Day 1 - Day 4: Water the first flower -> arr becomes [9, 8]
Day 5: Water the second flower -> arr becomes [9, 9]
```

## **üîí Constraints**

* $1 \le \text{arr.size()} \le 10^5$
* $1 \le w \le \text{arr.size()}$
* $1 \le k \le 10^5$
* $1 \le \text{arr}[i] \le 10^9$

## **‚úÖ My Approach**

The optimal approach uses **Binary Search on Answer** combined with a **Greedy Watering Strategy**:

### **Binary Search + Greedy Validation**

1. **Binary Search Setup:**
   * Search space: `[min(arr), min(arr) + k]`
   * For each candidate minimum height, check if it's achievable with k days

2. **Greedy Validation Strategy:**
   * Use a sliding window approach to simulate watering effects
   * Track cumulative water added using a frequency array
   * When a flower's height is below target, greedily add water to achieve the target
   * Early termination if we exceed k days

3. **Sliding Window Optimization:**
   * Maintain running sum of water effects within window w
   * Efficiently calculate current height by adding/removing window effects
   * Use prefix sum technique for optimal performance

4. **Maximize the Answer:**
   * If current target is achievable, try a higher target
   * If not achievable, reduce the target
   * Return the maximum achievable minimum height

## üìù Time and Auxiliary Space Complexity

* **Expected Time Complexity:** O(n log k), where n is the array size and k is the number of days. Binary search takes O(log k) iterations, and each validation takes O(n) time to simulate the watering process.
* **Expected Auxiliary Space Complexity:** O(n), as we use an auxiliary array to track the cumulative watering effects for each position in the garden.

## **üßë‚Äçüíª Code (C++)**

```cpp
class Solution {
public:
    bool isPossible(vector<int> &arr, int k, int w, int maxHeight) {
        int n = arr.size();
        vector<int> water(n, 0);
        for (int i = 0; i < n; i++) {
            if (i > 0) water[i] = water[i - 1];
            int currHeight = arr[i] + water[i];
            if (i >= w) currHeight -= water[i - w];
            if (currHeight < maxHeight) {
                int add = maxHeight - currHeight;
                water[i] += add;
                k -= add;
                if (k < 0) return false;
            }
        }
        return true;
    }
    
    int maxMinHeight(vector<int> &arr, int k, int w) {
        int n = arr.size();
        int low = arr[0];
        for (int i = 1; i < n; i++) {
            if (arr[i] < low) low = arr[i];
        }
        int high = low + k, ans = low;
        while (low <= high) {
            int mid = low + (high - low) / 2;
            if (isPossible(arr, k, w, mid)) {
                ans = max(ans, mid);
                low = mid + 1;
            } else {
                high = mid - 1;
            }
        }
        return ans;
    }
};
```

<details>
<summary><b>‚ö° View Alternative Approaches with Code and Analysis</b></summary>

## üìä **2Ô∏è‚É£ Optimized Space Approach with Sliding Window**

### üí° Algorithm Steps:

1. Use sliding window technique to track watering effects efficiently.
2. Maintain running sum of water added within window.
3. Apply binary search on answer with optimized space usage.

```cpp
class Solution {
public:
    bool canAchieve(vector<int>& arr, int k, int w, int target) {
        int n = arr.size();
        vector<int> added(n, 0);
        int windowSum = 0;
        
        for (int i = 0; i < n; i++) {
            if (i >= w) windowSum -= added[i - w];
            
            int currentHeight = arr[i] + windowSum;
            if (currentHeight < target) {
                int need = target - currentHeight;
                added[i] = need;
                windowSum += need;
                k -= need;
                if (k < 0) return false;
            }
        }
        return true;
    }
    
    int maxMinHeight(vector<int>& arr, int k, int w) {
        int minVal = *min_element(arr.begin(), arr.end());
        int left = minVal, right = minVal + k, result = minVal;
        
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (canAchieve(arr, k, w, mid)) {
                result = mid;
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return result;
    }
};
```

### üìù **Complexity Analysis:**

* **Time:** ‚è±Ô∏è O(n log k)
* **Auxiliary Space:** üíæ O(n) - For tracking water added

### ‚úÖ **Why This Approach?**

* Uses STL min_element for cleaner code.
* Optimized sliding window implementation.
* Better variable naming for clarity.

## üìä **3Ô∏è‚É£ Greedy with Prefix Sum Optimization**

### üí° Algorithm Steps:

1. Use prefix sum to efficiently calculate cumulative watering effects.
2. Apply greedy strategy with early termination.
3. Optimize binary search bounds.

```cpp
class Solution {
public:
    bool solve(vector<int>& heights, int days, int range, int minHeight) {
        int n = heights.size();
        vector<long long> water(n + range, 0);
        long long used = 0;
        
        for (int i = 0; i < n; i++) {
            long long current = heights[i] + water[i];
            if (current < minHeight) {
                long long need = minHeight - current;
                used += need;
                if (used > days) return false;
                water[i] += need;
                if (i + range < n + range) water[i + range] -= need;
            }
            if (i + 1 < n + range) water[i + 1] += water[i];
        }
        return true;
    }
    
    int maxMinHeight(vector<int>& arr, int k, int w) {
        int low = *min_element(arr.begin(), arr.end());
        int high = low + k;
        int answer = low;
        
        while (low <= high) {
            int mid = low + (high - low) / 2;
            if (solve(arr, k, w, mid)) {
                answer = mid;
                low = mid + 1;
            } else {
                high = mid - 1;
            }
        }
        return answer;
    }
};
```

### üìù **Complexity Analysis:**

* **Time:** ‚è±Ô∏è O(n log k)
* **Auxiliary Space:** üíæ O(n + w)

### ‚úÖ **Why This Approach?**

* Handles large numbers with long long.
* Efficient prefix sum technique.
* Optimized memory allocation.

## üÜö **üîç Comparison of Approaches**

| üöÄ **Approach**                          | ‚è±Ô∏è **Time Complexity** | üíæ **Space Complexity** | ‚úÖ **Pros**                        | ‚ö†Ô∏è **Cons**                           |
| ---------------------------------------- | ---------------------- | ----------------------- | --------------------------------- | ------------------------------------- |
| üîç **Binary Search + Frequency Array**   | üü¢ O(n log k)          | üü¢ O(n)                 | ‚ö° Simple implementation          | üßÆ Multiple array operations         |
| üîÑ **Sliding Window**                   | üü¢ O(n log k)          | üü¢ O(n)                 | üîß Optimized window tracking     | üíæ Similar space complexity         |
| üî∫ **Prefix Sum**                       | üü¢ O(n log k)          | üü° O(n + w)             | üöÄ Handles overflow, efficient   | üíæ Extra space for range           |

### üèÜ **Best Choice Recommendation**

| üéØ **Scenario**                                    | üéñÔ∏è **Recommended Approach**              | üî• **Performance Rating** |
| -------------------------------------------------- | ----------------------------------------- | ------------------------- |
| ‚ö° Competitive programming, simple implementation  | ü•á **Binary Search + Frequency Array**   | ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ                     |
| üîß Production code, optimized window operations   | ü•à **Sliding Window**                    | ‚òÖ‚òÖ‚òÖ‚òÖ‚òÜ                     |
| üìä Large numbers, overflow concerns               | ü•â **Prefix Sum**                        | ‚òÖ‚òÖ‚òÖ‚òÖ‚òÜ                     |

</details>

## **üßë‚Äçüíª Code (Java)**

```java
class Solution {
    boolean isPossible(int[] arr, int k, int w, int maxHeight) {
        int n = arr.length;
        int[] water = new int[n];
        for (int i = 0; i < n; i++) {
            if (i > 0) water[i] = water[i - 1];
            int currHeight = arr[i] + water[i];
            if (i >= w) currHeight -= water[i - w];
            if (currHeight < maxHeight) {
                int add = maxHeight - currHeight;
                water[i] += add;
                k -= add;
                if (k < 0) return false;
            }
        }
        return true;
    }
    
    public int maxMinHeight(int[] arr, int k, int w) {
        int n = arr.length;
        int low = arr[0];
        for (int i = 1; i < n; i++) {
            if (arr[i] < low) low = arr[i];
        }
        int high = low + k, ans = low;
        while (low <= high) {
            int mid = low + (high - low) / 2;
            if (isPossible(arr, k, w, mid)) {
                ans = Math.max(ans, mid);
                low = mid + 1;
            } else {
                high = mid - 1;
            }
        }
        return ans;
    }
}
```

## **üêç Code (Python)**

```python
class Solution:
    def isPossible(self, arr, k, w, maxHeight):
        n = len(arr)
        water = [0] * n
        for i in range(n):
            if i > 0:
                water[i] = water[i - 1]
            currHeight = arr[i] + water[i]
            if i >= w:
                currHeight -= water[i - w]
            if currHeight < maxHeight:
                add = maxHeight - currHeight
                water[i] += add
                k -= add
                if k < 0:
                    return False
        return True
    
    def maxMinHeight(self, arr, k, w):
        n = len(arr)
        low = min(arr)
        high = low + k
        ans = low
        while low <= high:
            mid = low + (high - low) // 2
            if self.isPossible(arr, k, w, mid):
                ans = max(ans, mid)
                low = mid + 1
            else:
                high = mid - 1
        return ans
```

## üß† Contribution and Support

For discussions, questions, or doubts related to this solution, feel free to connect on LinkedIn: [üì¨ Any Questions?](https://www.linkedin.com/in/patel-hetkumar-sandipbhai-8b110525a/). Let's make this learning journey more collaborative!

‚≠ê **If you find this helpful, please give this repository a star!** ‚≠ê

---

<div align="center">
  <h3><b>üìçVisitor Count</b></h3>
</div>

<p align="center">
  <img src="https://profile-counter.glitch.me/Hunterdii/count.svg" alt="Visitor counter" />
</p>
